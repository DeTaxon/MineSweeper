//TODO check what cause memory overuse


FieldBlock := class
{
	isMine := bool
	isDefused := bool
	isPressed := bool

	"=" := default
}

SweeperNuklear := class extend SimpleWindow
{
	unknownPlace := void^
	pressedPlace := void^
	pressedMinePlace := void^
	pressedMineDefused := void^

	SizeX := int
	SizeY := int

	mineField := Vector.{FieldBlock}

	mineBlank := NuklearObject
	minePressed := NuklearObject
	mineDefused := NuklearObject

	backgroundWindow := NuklearObject
	
	nonMinePressed := NuklearObject^[9]

	firstPress := bool

	lay := LayoutVertical^
	mineFieldView := MineField^
	
	InitWindow := virtual !(void^ nk) -> void
	{
	}
	InitField := !(int dimX, int dimY) -> void
	{
		SizeX = dimX
		SizeY = dimY

		mineField.Resize(dimX*dimY)

		ResetField()
	}
	GetField := !(int X,int Y) -> ref FieldBlock
	{
		return mineField[X + Y*SizeX]
	}

	ResetField := !() -> void
	{
		firstPress = true
		for it : mineField
		{
			it.isMine = false
			it.isPressed = false
			it.isDefused = false
		}

		mines := 35
		while mines != 0
		{
			x := RandInt(0..(SizeX-1))
			y := RandInt(0..(SizeY-1))

			if GetField(x,y).isMine
				continue
			GetField(x,y).isMine = true
			mines -= 1
		}
	}

	GetSpaceWeight := !(int x, int y) -> int
	{
		for it : ForAround(x,y,true)
		{
			if GetField(it.0,it.1).isMine
				result += 1
		}
	}
	DrawCode := virtual !(void^ nk,int w, int h) -> void
	{
		red := nk_color
		red.r = 255
		red.a = 255

		gray := nk_color
		gray.r = 128
		gray.g = gray.r
		gray.b = gray.r
		gray.a = 255

		if unknownPlace == null
		{
			unknownPlace = malloc(nke_style_button_size())
			nke_style_button_copy_from_context(nk,unknownPlace)
			//nke_style_button_set_color(unknownPlace,2,red)

			pressedPlace = malloc(nke_style_button_size())
			nke_style_button_copy_from_context(nk,pressedPlace)
			nke_style_button_set_color(pressedPlace,0,gray)
			nke_style_button_set_color(pressedPlace,1,gray)
			nke_style_button_set_color(pressedPlace,2,gray)

			pressedMinePlace = malloc(nke_style_button_size())
			nke_style_button_copy_from_context(nk,pressedMinePlace)
			nke_style_button_set_color(pressedMinePlace,0,red)
			nke_style_button_set_color(pressedMinePlace,1,red)
			nke_style_button_set_color(pressedMinePlace,2,red)


			green := nk_color
			green.g = 255
			green.a = 255

			pressedMineDefused = malloc(nke_style_button_size())
			nke_style_button_copy_from_context(nk,pressedMineDefused)
			nke_style_button_set_color(pressedMineDefused,0,green)
			nke_style_button_set_color(pressedMineDefused,1,green)
			nke_style_button_set_color(pressedMineDefused,2,green)

			nk_style_hide_cursor(nk)

			mineBlank.Create(vInstance,nk,unknownPlace,"")
			mineBlank.drawLayout = this.drawLayout

			minePressed.Create(vInstance,nk,pressedMinePlace,"")
			minePressed.drawLayout = this.drawLayout

			mineDefused.Create(vInstance,nk,pressedMineDefused,"")
			mineDefused.drawLayout = this.drawLayout

			for i : 9
			{
				nonMinePressed[i] = new NuklearObject
				nonMinePressed[i].Create(vInstance,nk,pressedPlace,!["","1","2","3","4","5","6","7","8"][i])
				nonMinePressed[i].drawLayout = this.drawLayout
			}

			backgroundWindow.CreateWindow(vInstance,nk,w,h)
			backgroundWindow.drawLayout = this.drawLayout

			mineFieldView = new MineField(this&,15,15)

			resetButton := new Button(0,40,"Reset")
			resetButton.drawLayout = this.drawLayout
			lay = new LayoutVertical(![
				new LayoutSpacer("static",20),
				resetButton,
				new LayoutSpacer("static",20),
				mineFieldView
			])

			resetButton.SetPressCallback(() ==> {
				ResetField()
			})
			lay.GetLayout()
			lay.SetLayout(nuklearContext,vec2f(w,h))
		}
	}
	PressField := !(int x, int y) -> int
	{
		if GetField(x,y).isPressed
			return 0
		GetField(x,y).isPressed = true
		if GetSpaceWeight(x,y) != 0
			return 1

		result = 1
		for it : ForAround(x,y)
		{
			result += PressField(it.0,it.1)
		}
	}
	PressAssist := !(int x, int y) -> void
	{
		if not GetField(x,y).isPressed
			return void

		unpressed := 0
		foundMines := 0
		totalMines := 0

		for it : ForAround(x,y)
		{
			chk := ref GetField(it.0,it.1)
			if chk.isDefused
				foundMines += 1
			if chk.isMine
				totalMines += 1
			if not chk.isPressed
				unpressed += 1
		}

		if foundMines + unpressed == totalMines
		{
			for it : ForAround(x,y)
			{
				PressRight(it.0,it.1)
			}
		}else if totalMines == foundMines and unpressed != 0
		{
			for it : ForAround(x,y)
			{
				PressField(it.0,it.1)
			}
		}
	}

	PressRight := !(int x,int y) -> void
	{
		fld := ref GetField(x,y)
		if fld.isPressed
			return void

		if fld.isMine
		{
			fld.isPressed = true
			fld.isDefused = true
		}else{
			//printf("nah\n")
		}
	}


	DrawVulkan := virtual !(VkCommandBuffer cmd,int w, int h) -> void
	{
		backgroundWindow.PushDraw(cmd,w,h,vec2f(0,0))
		lay.PushDraw(cmd,w,h,vec2f(0,0))
	}

	MousePressed := virtual !(int buttonNum, bool pressed, int mods) -> void //if pressed is false => released
	{
		if not pressed
			return void
		lay.MousePressed(buttonNum,pressed,vec2f(MouseX,MouseY))
	}

	ForAround := !(int x, int y,bool useMiddle = false) -> ProxyForSweeper
	{
		result.base = this&
		result.dimX = x
		result.dimY = y
		result.useMiddle = useMiddle
	}
}

ProxyForSweeper := class
{
	base := SweeperNuklear^
	dimX := int
	dimY := int
	useMiddle := bool

	"for" := !() -> !()&-> Tuple.{int,int}
	{
		lambd := () ==> Tuple.{int,int}
		{
			diffs := ![-1,0,1]
			for dX : diffs
			{
				newX := dimX + dX
				if newX < 0 or newX >= base.SizeX
					continue
				for dY : diffs
				{
					if dX == 0 and dY == 0 and not useMiddle
						continue
					newY := dimY + dY
					if newY < 0 or newY >= base.SizeY
						continue

					yield !{newX,newY}
				}
			}
			
		}
		return lambd.Capture()
	}
}


main := !(char^[] args) -> void
{
	w := new SweeperNuklear(700,700,"MineSweeper")
	w.InitField(15,15)
	w.SetFPSLimit(30)
	w.Run()
}
