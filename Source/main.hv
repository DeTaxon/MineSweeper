//TODO windows support
//TODO make video card selector, it force
//TODO check what couse memory overuse
//TODO redraw when only mouse moved?
//TODO nk_convert have it's limits, maybe overwrite library?


FieldBlock := class
{
	isMine := bool
	isDefused := bool
	isPressed := bool

	"=" := default
}

SweeperNuklear := class extend SimpleWindow
{
	unknownPlace := void^
	pressedPlace := void^
	pressedMinePlace := void^
	pressedMineDefused := void^


	SizeX := int
	SizeY := int


	mineField := Vector.{FieldBlock}

	mineBlank := NuklearObject
	minePressed := NuklearObject
	mineDefused := NuklearObject
	
	nonMinePressed := NuklearObject^[9]
	
	InitWindow := virtual !(void^ nk) -> void
	{
	}
	InitField := !(int dimX, int dimY) -> void
	{
		SizeX = dimX
		SizeY = dimY

		mineField.Resize(dimX*dimY)

		ResetField()
	}
	GetField := !(int X,int Y) -> ref FieldBlock
	{
		return mineField[X + Y*SizeX]
	}

	ResetField := !() -> void
	{
		for it : mineField
		{
			it.isMine = false
			it.isPressed = false
			it.isDefused = false
		}

		mines := 35
		while mines != 0
		{
			x := RandInt(0..(SizeX-1))
			y := RandInt(0..(SizeY-1))

			if GetField(x,y).isMine
				continue
			GetField(x,y).isMine = true
			mines -= 1
		}
	}

	GetSpaceWeight := !(int x, int y) -> int
	{
		diffs := ![-1,0,1]
		for dX : diffs
		{
			newX := x + dX
			if newX < 0 or newX >= SizeX
				continue
			for dY : diffs
			{
				newY := y + dY
				if newY < 0 or newY >= SizeY
					continue
				if GetField(newX,newY).isMine
					result += 1
			}
		}
	}
	DrawCode := virtual !(void^ nk,int w, int h) -> void
	{
		red := nk_color
		red.r = 255
		red.a = 255

		gray := nk_color
		gray.r = 128
		gray.g = gray.r
		gray.b = gray.r
		gray.a = 255

		if unknownPlace == null
		{
			unknownPlace = malloc(nke_style_button_size())
			nke_style_button_copy_from_context(nk,unknownPlace)
			//nke_style_button_set_color(unknownPlace,2,red)

			pressedPlace = malloc(nke_style_button_size())
			nke_style_button_copy_from_context(nk,pressedPlace)
			nke_style_button_set_color(pressedPlace,0,gray)
			nke_style_button_set_color(pressedPlace,1,gray)
			nke_style_button_set_color(pressedPlace,2,gray)

			pressedMinePlace = malloc(nke_style_button_size())
			nke_style_button_copy_from_context(nk,pressedMinePlace)
			nke_style_button_set_color(pressedMinePlace,0,red)
			nke_style_button_set_color(pressedMinePlace,1,red)
			nke_style_button_set_color(pressedMinePlace,2,red)


			green := nk_color
			green.g = 255
			green.a = 255

			pressedMineDefused = malloc(nke_style_button_size())
			nke_style_button_copy_from_context(nk,pressedMineDefused)
			nke_style_button_set_color(pressedMineDefused,0,green)
			nke_style_button_set_color(pressedMineDefused,1,green)
			nke_style_button_set_color(pressedMineDefused,2,green)

			nk_style_hide_cursor(nk)

			mineBlank.Create(this&,nk,unknownPlace,"")
			mineBlank.drawLayout = this.drawLayout

			minePressed.Create(this&,nk,pressedMinePlace,"")
			minePressed.drawLayout = this.drawLayout

			mineDefused.Create(this&,nk,pressedMineDefused,"")
			mineDefused.drawLayout = this.drawLayout

			for i : 9
			{
				nonMinePressed[i] = new NuklearObject
				nonMinePressed[i].Create(this&,nk,pressedPlace,!["","1","2","3","4","5","6","7","8"][i])
				nonMinePressed[i].drawLayout = this.drawLayout
			}
		}

		rect := nk_rect//(10,10,100,100)
		rect.x = 0
		rect.y = 0
		rect.w = w
		rect.h = h

		rect2 := nk_rect

		boxSize := 30
		margin := 2
		
		rowSize := boxSize*SizeX + margin*(SizeX - 1)
		leftSize := (w - rowSize) / 2

		if nk_begin(nk,"MainWindow2",rect,32) != 0
		{

			nk_layout_space_begin(nk,NK_STATIC,w,SizeX*SizeY + 1)

			rect2.x = leftSize
			rect2.y = 20
			rect2.w = rowSize
			rect2.h = 40

			nk_layout_space_push(nk,rect2)

			if nk_button_label(nk,"Reset")
			{
				ResetField()
			}

			nk_layout_space_end(nk)
		}
		nk_end(nk)
	}
	PressField := !(int x, int y) -> void
	{
		if GetField(x,y).isPressed
			return void
		GetField(x,y).isPressed = true
		if GetSpaceWeight(x,y) != 0
			return void

		diffs := ![-1,0,1]
		for dX : diffs
		{
			newX := x + dX
			if newX < 0 or newX >= SizeX
				continue
			for dY : diffs
			{
				newY := y + dY
				if newY < 0 or newY >= SizeY
					continue
				PressField(newX,newY)
			}
		}
	}
	PressAssist := !(int x, int y) -> void
	{
		if not GetField(x,y).isPressed
			return void

		unpressed := 0
		foundMines := 0
		totalMines := 0

		diffs := ![-1,0,1]
		for dX : diffs
		{
			newX := x + dX
			if newX < 0 or newX >= SizeX
				continue
			for dY : diffs
			{
				newY := y + dY
				if newY < 0 or newY >= SizeY
					continue
				if newX == x and newY == y
					continue
				chk := ref GetField(newX,newY)
				if chk.isDefused
					foundMines += 1
				if chk.isMine
					totalMines += 1
				if not chk.isPressed
					unpressed += 1
			}
		}

		if foundMines + unpressed == totalMines
		{
			for dX : diffs
			{
				newX := x + dX
				if newX < 0 or newX >= SizeX
					continue
				for dY : diffs
				{
					newY := y + dY
					if newY < 0 or newY >= SizeY
						continue
					if newX == x and newY == y
						continue
					
					PressRight(newX,newY)
				}
			}
		}else if totalMines == foundMines and unpressed != 0
		{
			for dX : diffs
			{
				newX := x + dX
				if newX < 0 or newX >= SizeX
					continue
				for dY : diffs
				{
					newY := y + dY
					if newY < 0 or newY >= SizeY
						continue
					if newX == x and newY == y
						continue
					PressField(newX,newY)
				}
			}
		}
	}

	PressRight := !(int x,int y) -> void
	{
		fld := ref GetField(x,y)
		if fld.isPressed
			return void

		if fld.isMine
		{
			fld.isPressed = true
			fld.isDefused = true
		}else{
			//printf("nah\n")
		}
	}


	DrawVulkan := virtual !(VkCommandBuffer cmd,int w, int h) -> void
	{
		rect2 := nk_rect

		boxSize := 30
		margin := 2
		
		rowSize := boxSize*SizeX + margin*(SizeX - 1)
		leftSize := (w - rowSize) / 2
		
		for x : SizeX
		{
			for y : SizeY
			{
				rect2.x = leftSize + x*(boxSize + margin)
				rect2.y = 80 + y*(boxSize + margin)
				rect2.w = 30
				rect2.h = 30

				fld := GetField(x,y)

				if fld.isPressed
				{
					if fld.isMine
					{
						if fld.isDefused
						{
							mineDefused.PushDraw(cmd,w,h,rect2.x,rect2.y)
						}else{
							minePressed.PushDraw(cmd,w,h,rect2.x,rect2.y)
						}
					}else{
						wdth := GetSpaceWeight(x,y)
						nonMinePressed[wdth].PushDraw(cmd,w,h,rect2.x,rect2.y)
					}
				}else{
					mineBlank.PushDraw(cmd,w,h,rect2.x,rect2.y)
				}
			}
		}
	}

	MouseX := double
	MouseY := double
	MouseMoved := virtual !(double x, double y) -> void
	{
		MouseX = x
		MouseY = y
	}

	KeyChanged := virtual !(int key, int scancode, bool pressed) -> void
	{
	}
	M2Pressed := bool
	MousePressed := virtual !(int buttonNum, bool pressed, int mods) -> void //if pressed is false => released
	{

		if buttonNum == 1
			M2Pressed = pressed

		if not pressed
			return void

		rect2 := nk_rect

		boxSize := 30
		margin := 2
		
		rowSize := boxSize*SizeX + margin*(SizeX - 1)
		leftSize := (700 - rowSize) / 2 //TODO unconst

		minX := leftSize
		maxX := leftSize + SizeX*(boxSize + margin) - margin
		minY := 80
		maxY := 80 + SizeY*(boxSize + margin) - margin

		if MouseX > maxX or MouseX < minX
			return void
		if MouseY > maxY or MouseY < minY
			return void
 
		indX := (MouseX - minX) / (30 + margin)
		indY := (MouseY - minY) / (30 + margin)

		switch buttonNum
		{
			case 0
				if M2Pressed
				{
					PressAssist(indX,indY)
				}else{
					PressField(indX,indY)
				}
			case 1
				PressRight(indX,indY)
		}
	}
}


main := !(char^[] args) -> void
{
	w := new SweeperNuklear(700,700,"MineSweeper")
	w.InitField(15,15)
	w.SetFPSLimit(30)
	w.Run()
}
