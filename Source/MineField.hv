meshData := class
{
	pos := float[2]
	uv := float[2]
	color := u8[4]
}

MineField := class extend GUIObject
{
	boxSize := float
	margin := float

	base := SweeperNuklear^

	mineBlank := NkButton^
	minePressed := NkButton^
	mineDefused := NkButton^
	nonMinePressed := NkButton^[9]

	quadMesh := TVkMesh^
	quadSmallMesh := TVkMesh^


	tilesPool := TDescriptorPool^ 

	flagTile := Tile
	bombTile := Tile
	backgroundTile := Tile
	blankTiles := Tile[2]
	numbersTile := Tile[10]

	this := !(SweeperNuklear^ bck,int x, int y) -> void
	{
		base = bck
		boxSize = 30.0
		margin = 2.0

		SetSize("static",boxSize*x + margin*(x - 1), "static", boxSize*y + margin*(y - 1))

		tilesPool := base.drawLayout.CreateDescriptorPool(0,20)

		verts := meshData[4]

		for it,i : ![!{0.0,0.0} ,!{1.0,0.0} ,!{0.0,1.0} ,!{1.0,1.0}]
		{
			verts[i].pos[0] = 30.0*it.0
			verts[i].pos[1] = 30.0*it.1
			verts[i].uv[0] = it.0
			verts[i].uv[1] = it.1
			verts[i].color[0] = 255
			verts[i].color[1] = 255
			verts[i].color[2] = 255
			verts[i].color[3] = 255
		}
		inds := ref ![0,1,2,1,3,2]

		quadMesh = base.vInstance.CreateMesh(TArraySpan.{u8}(verts[0]&->{u8^},4*meshData->TypeSize),TArraySpan.{u8}(inds[0]&->{u8^},6*4),VKType(VType_UInt32,1))

		smallSide := 0.15
		bigSide := 0.85
		for it,i : ![!{smallSide,smallSide} ,!{bigSide,smallSide} ,!{smallSide,bigSide} ,!{bigSide,bigSide}]
		{
			verts[i].pos[0] = 30.0*it.0
			verts[i].pos[1] = 30.0*it.1
		}
		quadSmallMesh = base.vInstance.CreateMesh(TArraySpan.{u8}(verts[0]&->{u8^},4*meshData->TypeSize),TArraySpan.{u8}(inds[0]&->{u8^},6*4),VKType(VType_UInt32,1))

		flagTile.Create(base,tilesPool,FSGetFile("Textures/Flag.webp"))
		bombTile.Create(base,tilesPool,FSGetFile("Textures/Bomb.webp"))
		backgroundTile.Create(base,tilesPool,FSGetFile("Textures/Background.webp"))
		blankTiles[0].Create(base,tilesPool,FSGetFile("Textures/Tile1.webp"))
		blankTiles[1].Create(base,tilesPool,FSGetFile("Textures/Tile2.webp"))
		
		for i : 1..8
		{
			numbersTile[i].Create(base,tilesPool,FSGetFile(CreateString("Textures/",i,".webp")))
		}

	}
	PushDraw := virtual !(VkCommandBuffer cmdB,int w,int h,vec2f offset) -> void
	{
		rect2 := nk_rect
		for x : base.SizeX
		{
			for y : base.SizeY
			{
				rect2.x = offset.x + x*(boxSize + margin)
				rect2.y = offset.y + y*(boxSize + margin)
				rect2.w = boxSize
				rect2.h = boxSize

				fld := base.GetField(x,y)

				if fld.isPressed
				{
					if fld.isMine
					{
						if fld.isDefused
						{
							//mineDefused.drawLayout = this.drawLayout
							//mineDefused.PushDraw(cmdB,w,h,vec2f(rect2.x,rect2.y))
						}else{
							minePressed.drawLayout = this.drawLayout
							minePressed.PushDraw(cmdB,w,h,vec2f(rect2.x,rect2.y))
						}
					}else{
						wdth := base.GetSpaceWeight(x,y)
						nonMinePressed[wdth].drawLayout = this.drawLayout
						nonMinePressed[wdth].PushDraw(cmdB,w,h,vec2f(rect2.x,rect2.y))
					}
				}
			}
		}

		for x : base.SizeX
		{
			for y : base.SizeY
			{
				rect2.x = offset.x + x*(boxSize + margin)
				rect2.y = offset.y + y*(boxSize + margin)
				rect2.w = boxSize
				rect2.h = boxSize

				fld := base.GetField(x,y)

				if fld.isPressed
				{
					if fld.isMine
					{
						if fld.isDefused
						{
							blankTiles[ (x + y) and_b 1 ].Draw(base,cmdB,quadMesh,drawLayout,w,h,vec2f(rect2.x,rect2.y))
							flagTile.Draw(base,cmdB,quadSmallMesh,drawLayout,w,h,vec2f(rect2.x,rect2.y))
						}else{
							backgroundTile.Draw(base,cmdB,quadMesh,drawLayout,w,h,vec2f(rect2.x,rect2.y))
							bombTile.Draw(base,cmdB,quadMesh,drawLayout,w,h,vec2f(rect2.x,rect2.y))
						}
					}else{
						wdth := base.GetSpaceWeight(x,y)
						backgroundTile.Draw(base,cmdB,quadMesh,drawLayout,w,h,vec2f(rect2.x,rect2.y))
						if wdth in 1..8
						{
							numbersTile[wdth].Draw(base,cmdB,quadSmallMesh,drawLayout,w,h,vec2f(rect2.x,rect2.y))	
						}
					}
				}else{
					blankTiles[ (x + y) and_b 1 ].Draw(base,cmdB,quadMesh,drawLayout,w,h,vec2f(rect2.x,rect2.y))
				}
			}
		}
	}

	SetLayout := virtual !(NuklearVulkanContext^ ctx,vec2f setSize) -> void
	{
		super(ctx,setSize)
		if mineBlank == null
		{
			mineBlank = new NkButton(base.nuklearContext,30,30,"")
			mineBlank.SetLayout(ctx,vec2f(30,30))

			minePressed = new NkButton(base.nuklearContext,30,30,"")
			minePressed.SetColor("normal",255,0,0)
			minePressed.SetLayout(ctx,vec2f(30,30))

			mineDefused = new NkButton(base.nuklearContext,30,30,"")
			mineDefused.SetColor("normal",0,255,0)
			mineDefused.SetLayout(ctx,vec2f(30,30))

			numbers := !["","1","2","3","4","5","6","7","8"]
			for i : 9
			{
				nonMinePressed[i] = new NkButton(base.nuklearContext,30,30,numbers[i])
				nonMinePressed[i].SetColor("normal",128,128,128)
				nonMinePressed[i].SetLayout(ctx,vec2f(30,30))
			}
		}

	}
	MousePressed := virtual !(int buttonNum, bool pressed,vec2f offset) -> void
	{
		if not pressed
			return void

		indX := offset.x / (boxSize + margin)
		indY := offset.y / (boxSize + margin)

		switch buttonNum
		{
			case 0
				if base.M2Pressed
				{
					base.PressAssist(indX,indY)
				}else{
					if base.firstPress
					{
						while base.PressField(indX,indY) < 10
						{
							base.ResetField()
						}
						base.firstPress = false
					}else{
						base.PressField(indX,indY)
					}
				}
			case 1
				base.PressRight(indX,indY)
		}
	}
}
